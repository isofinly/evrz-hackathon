// <REVIEW> Файлы с расширением tsx и отображающие контент должны быть с большой буквы</REVIEW>
// <REVIEW> Импорт сторонних библиотек которые можно написать самому, запрещено на подобии react-i18next</REVIEW>
// <REVIEW> Использование стороних библиотек запрещено @mui и Material-UI</REVIEW>
// <REVIEW> переменная должна иметь явный смысл в своем названии</REVIEW>
// <REVIEW> Данный файл является компонентой и должен по пути "/src/Components/{название папки}/{название файла}.tsx"</REVIEW>
// <REVIEW> Создание домена для хранилища должна быть по пути /src/Model/{название}/state.ts </REVIEW>
// <REVIEW> Данный файл является контейнером и должен по пути"/src/Containers/{название папки}/{название файла}.tsx"</REVIEW>
// <REVIEW> Подключение шрифтов должно быть в одном файле css на одном уравне со шрифтами</REVIEW>
// <REVIEW> Функция является hook и должно находиться "/src/Hook/"</REVIEW>
// <REVIEW> Название файла должна быть в формате CamelCase</REVIEW>
// <REVIEW> еффект должн происходить в хранилище по пути /src/Model/{название}/effects/effect.ts</REVIEW>
// <REVIEW> формирование запроса должно быть в хранилище по пути /src/Model/{название}/effects/effect.ts</REVIEW>
// <REVIEW> Тип нужно выносить в файл types.ts на одном уровне с хранилищем</REVIEW>
// <REVIEW> Описание интерфеса или типа должно быть в файле types.ts на одном уровне с контейнером</REVIEW>
// <REVIEW> переменная должна иметь явный смысл в своем названии</REVIEW>
//<REVIEW> Имя типа должно отражать то, что он описывает</REVIEW>
// <REVIEW> Файла с расширением .module.css.d.ts быть не должно</REVIEW>
// <REVIEW> Комбинирование должно быть по пути /src/Model/{название}/state.ts</REVIEW>
// <REVIEW> сэмплирование должно происходить в хранилище по пути /src/Model/{название}/state.ts</REVIEW>
// <REVIEW> <b></b> не использовать, только стилистика</REVIEW>
// <REVIEW> данный файл должен находиться по пути "/src/Assets/SVG/reactQueryIcon.svg"</REVIEW>
// <REVIEW> перевод к строке долджен быть String(date.getMinutes())  и получим const minutes = String(date.getMinutes()).padStart(2, "0")</REVIEW>
// <REVIEW> нужно использовать интерполяцию для получения string переменной из нескольких параметров, `${minutes}:${seconds}:${millisecondsEnd}`</REVIEW>
// <REVIEW> Данная функция является утилитой и должна находиться по пути "/src/utils/convertMillisecondsAndDateToTime.ts" </REVIEW>
//  <REVIEW> Не используемых переменных не должно быть, например <Container className={styles.root} py={3}></REVIEW>
//  <REVIEW> данный файл должен находиться по пути "/src/pages/ResultsPage/ResultsPage.tsx"</REVIEW>
//  <REVIEW> Типизация props параметров UseOpenHelpModalReturn должна находиться по пути "/src/pages/RootPage/RootPage.type"</REVIEW>
//  <REVIEW> Стили должны передаваться через props параметры style или className </REVIEW>
// <REVIEW> переменная является константой и должна находиться по пути "/src/shared/constants.ts </REVIEW>
//  <REVIEW> {" > "} нужно заменить на svg элемент</REVIEW>
// <REVIEW> Фильтрация события должно происходить в хранилище по пути /src/Model/{название}/state.ts</REVIEW>
// <REVIEW> хранение состояние в переменной должно происходить в хранилище по пути /src/Model/{название}/state.ts</REVIEW>
// <REVIEW> создание еффекта должно происходить в хранилище по пути /src/Model/{название}/effects/effect.ts</REVIEW>
//<REVIEW> Данный компонент возвращает статичный список элементов и от не меняется. С целью упростить компонент и понимание кода - стоит занести список в константу и рендерить компонент по этому списку.</REVIEW>
//<REVIEW> Использование утилиты clsx лишь для одного имени класса не имеет смысла</REVIEW>
//<REVIEW> В парадигме React обращение к элементам через DOM используется через createRef/useRef</REVIEW>
// <REVIEW> Стилистика, которая не зависит от перемнных должна быть в className</REVIEW>
// <REVIEW> Данный интерфейс является интерфейсом для компоненты и должен находиться в файле types.ts на одном уровне с компонентой</REVIEW>
// <REVIEW> событие должно происходить в хранилище по пути /src/Model/{название}/events/event.ts</REVIEW>
// <REVIEW> button должен иметь пол type</REVIEW>
// <REVIEW> должно быть явное указание тип, unknown запрещен</REVIEW>
// <REVIEW> enum для хранилища должен находиться в одном каталоке с стором в файле с расширениемtypes/REVIEW>
// <REVIEW> Условный оператор должен иметь фигурные скобки</REVIEW>
// <REVIEW> Стили className должны быть модульными</REVIEW>
// <REVIEW> запуск клиента нужно перенести в /utils/initHighlight</REVIEW>
// <REVIEW> инициализацию клиента нужно перенести в /utils/initHighlight</REVIEW>
//<REVIEW> В парадигме effctor имена сторов должны начинаться со знака "$"</REVIEW>
//<REVIEW> В настоящее время поддержка guard в effector прекращена. Вместо него рекомендуется использовать sample</REVIEW>
//<REVIEW> Данный сайд-эффект использует лишь одну зависимость для одного стора. Рекомендуется использовать обработчик событий .on</REVIEW>
//<REVIEW> Данная реализация лишена смысла</REVIEW>
//<REVIEW> По стандартам разработки в EVRAZ - мы не используем styled-components. Вместо этого спользуйте css-modules</REVIEW>
//<REVIEW> По стандартам разработки - использование any стоит избегать. Вместо этого - протипизируйте дженерик</REVIEW>
//<REVIEW> Требование: файл стилей должен находиться в одной папке с компонентом.</REVIEW>
//<REVIEW> Требование: файлы статики должны находиться в соответствующих директориях - в папке public.</REVIEW>
//<REVIEW> Конкатинация строк должна происходить внутри бектиков - `${e.price} Руб.`</REVIEW>
//<REVIEW> Рассмотрите возможность сделать нейминг элементов более читаемым</REVIEW>
//<REVIEW> Добавьте описание для alt, чтобы улучшить доступность. Это важно для пользователей с ограниченными возможностями.</REVIEW>
//<REVIEW> Используйте уникальный идентификатор для ключа, например, e.name или e.picture, чтобы избежать потенциальных проблем с производительностью.</REVIEW>
//<REVIEW> Рассмотрите возможность использования useCallback для оптимизации функции onClick. Это может улучшить производительность компонента.</REVIEW>
// <REVIEW> Для пропсов с положительным bool не нужно присваивать "={true}"</REVIEW>
//<REVIEW> Рассмотрите возможность вынесения StockObjects в отдельный файл или получение данных из API. Это улучшит поддерживаемость и тестируемость кода.</REVIEW>
// <REVIEW> Данный компонент содержит модель effector и бизнес-логику. Перенесите данный компонент в src/Containers/SwipperList/SwipperList.tsx</REVIEW>
//<REVIEW> Проверьте, что путь к компоненту корректен и компонент используется по назначению.</REVIEW>
// <REVIEW> Вложенность JSX-кода может быть упрощена. Рассмотрите возможность вынесения условных операторов в отдельные переменные для улучшения читаемости.</REVIEW>
//<REVIEW> Инлайн-стили лучше избегать, если это возможно. Рассмотрите возможность переноса стилей в CSS-файл.</REVIEW>
//<REVIEW> Рассмотрите возможность использования деструктуризации параметров для улучшения читаемости.</REVIEW>
//<REVIEW> Добавьте комментарии к полям интерфейса для улучшения понимания их назначения.</REVIEW>
//<REVIEW> Требование: название интерфейса должно быть в формате <ComponentName>Props, например, BigPictureProps.</REVIEW>
//<REVIEW> Данная константа должна иметь имя BASE_URL</REVIEW>
//<REVIEW> Данный компонент содержит много логики, его следует разделить на более мелкие атомарные компоненты</REVIEW>
//<REVIEW> Имя данного компонента не отражает его функциональность</REVIEW>
//<REVIEW> Fragment в данном случае не имеет смысла, его стоит убрать</REVIEW>
//<REVIEW> Для улучшения читаемости кода - необходимо вынести список опций в константу</REVIEW>
//<REVIEW> Данный компонент возвращает статичный список элементов и от не меняется. С целью упростить компонент и понимание кода - стоит занести список в константу и рендерить компонент по этому списку.</REVIEW>
//<REVIEW> Данный обработчик должен находиться в файле src/models/filters/filters.model.ts</REVIEW>
// <REVIEW> обработка статуса загрузки не требуется, effector может отслеживать статус pending эффекта</REVIEW>
// <REVIEW> Предпочитайте использование обычных функций вместо стрелочных, за исключением случаев простых колбэков.</REVIEW>
// <REVIEW> Стрелочные функции НЕЛЬЗЯ использовать как методы объектов, так как это может привести к ошибкам с контекстом this. Используйте обычные функции.</REVIEW>
// <REVIEW> Имена булевых переменных и функций должны быть сформулированы как вопросы, на которые можно ответить "да" или "нет". Например, isVisible, hasError.</REVIEW>
// <REVIEW> При использовании css-modules следуйте методологии BEM: класс корневого элемента - .root, модификаторы отделяются двойным подчёркиванием, например, .button__active.</REVIEW>
// <REVIEW> Структура проекта должна включать каталоги: Adapters, API, Assets, Facades, Models, Shared, Pages, а также файлы index.css, main.tsx и routing.tsx. Каждый раздел имеет свои требования к содержимому и назначению.</REVIEW>
// <REVIEW> Адаптеры должны соответствовать схеме именования (например, fetch[FetchName]Adapter.ts) и реализовывать функции преобразования с именами, начинающимися на convert... с указанием типов данных. Например: function convertMeltInfoOriginToMeltInfo(origin: ResponseMeltInfo): MeltInfo.</REVIEW>
// <REVIEW> Модели Effector должны быть организованы в каталоге src/Models. Используйте стандартную структуру: events.ts, effects.ts, store.ts, index.ts.</REVIEW>
// <REVIEW> Для упрощённого доступа к модели создавайте фасады в папке src/Facades. Фасад должен предоставлять взаимодействие с одним разделом модели.</REVIEW>
// <REVIEW> Разделяйте виды компонентов по их назначению:
// - UI Kit: абстрактные UI-компоненты для повторного использования.
// - Components: UI-компоненты, специфичные для модуля.
// - Containers: компоненты, работающие с данными.
// - Pages: компоненты-экраны.</REVIEW>
// <REVIEW> Типизация компонентов обязательна. Интерфейс для props должен включать className?: string и style?: React.CSSProperties.</REVIEW>
// <REVIEW> Для сложных компонентов используйте CSS Custom Properties с шаблоном именования: --<имя-элемента>-<название-стиля>-<модификатор>.</REVIEW>
// <REVIEW> Порядок импортов должен быть стандартизирован: сначала сторонние библиотеки, затем внутренние модули.</REVIEW>
// <REVIEW> В каталоге компонента должна быть соблюдена структура: index.ts (для экспорта), <ComponentName>.tsx (основной файл), <ComponentName>.module.css (стили), types.ts (типизация), utils.ts (утилиты).</REVIEW>
// <REVIEW> В проекте должен присутствовать файл routing.tsx для конфигурации маршрутизации. Размещается в корне src.</REVIEW>
// <REVIEW> Файл index.css должен содержать глобальные стили приложения и находиться в корне src.</REVIEW>
// <REVIEW> Файл main.tsx должен быть точкой входа в приложение и находиться в корне src.</REVIEW>
// <REVIEW>Исключений быть не должно</REVIEW>
