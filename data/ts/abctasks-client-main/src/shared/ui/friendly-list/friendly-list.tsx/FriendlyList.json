{"start_line": 59, "code": "FriendlyList = <RawData, Item, Error>(\n\n\tprops: FriendlyListProps<RawData, Item, Error>\n\n): React.ReactElement => {\n\tconst {\n\t\t$query,\n\t\tgetData,\n\t\tgetKey,\n\t\temptyText,\n\t\tErrorComponent,\n\t\tItemComponent,\n\t\tSkeletonComponent,\n\t\tskeletonsCount,\n\t\tclassName,\n\t\tslots,\n\t\tdisableBorder,\n\t\tclasses,\n\t\trootProps,\n\t} = props;\n\n\tconst finished = useUnit($query.finished);\n\tconst [alreadyFetched, setAlreadyFetched] = React.useState(finished);\n\n\tReact.useEffect(() => {\n\t\tif (finished) {\n\t\t\tsetAlreadyFetched(finished);\n\t\t}\n\t}, [finished]);\n\n\tconst query = useUnit($query as Query<any, Item[] | RawData, any>);\n\n\tconst arrayData = (getData ? getData(query.data as RawData) : query.data) as\n\t\t| Item[]\n\t\t| null;\n\n\tconst isEmpty = !arrayData?.length;\n\tconst isLoading = query.pending && !alreadyFetched;\n\tconst isError = !query.error;\n\n\tlet content: React.ReactElement | null = null;\n\n\tif (!isError) {\n\t\tcontent = (\n\t\t\t<Center>\n\t\t\t\t{React.createElement(ErrorComponent, { error: query.error })}\n\t\t\t</Center>\n\t\t);\n\t} else if (isLoading) {\n\t\tconst array = getEmptyArray(skeletonsCount);\n\t\tconst count = array.length;\n\n\t\tconst skeletons = array.map((_, index) =>\n\t\t\tReact.createElement(SkeletonComponent, {\n\t\t\t\tkey: index,\n\t\t\t\tdivider: index + 1 !== count,\n\t\t\t} as any)\n\t\t);\n\n\t\tcontent = (\n\t\t\t<Scrollable direction='vertical'>\n\t\t\t\t<List className={classes?.list} disablePadding>\n\t\t\t\t\t{skeletons}\n\t\t\t\t</List>\n\t\t\t</Scrollable>\n\t\t);\n\t} else if (isEmpty) {\n\t\tcontent = (\n\t\t\t<Center>\n\t\t\t\t<Typography fontWeight={500}>{emptyText}</Typography>\n\t\t\t</Center>\n\t\t);\n\t} else {\n\t\tconst count = arrayData.length;\n\t\tconst items = arrayData.map((item, index) =>\n\t\t\tReact.createElement(ItemComponent, {\n\t\t\t\t...item,\n\t\t\t\tdivider: index + 1 !== count,\n\t\t\t\tkey: getKey(item),\n\t\t\t} as any)\n\t\t);\n\n\t\tcontent = (\n\t\t\t<Scrollable direction='vertical'>\n\t\t\t\t<List className={classes?.list} disablePadding>\n\t\t\t\t\t{items}\n\t\t\t\t</List>\n\t\t\t</Scrollable>\n\t\t);\n\t}\n\n\tconst hasBeforeSlot = !!slots?.before;\n\tconst hasAfterSlot = !!slots?.after;\n\tconst slotBefore = hasBeforeSlot ? <Center>{slots.before}</Center> : null;\n\tconst slotAfter = hasAfterSlot ? <Center>{slots.after}</Center> : null;\n\n\tconst hasBothSlot = hasBeforeSlot && hasAfterSlot;\n\n\tconst paperClasses = cn(\n\t\tstyles.paper,\n\t\t{\n\t\t\t[styles.after]: hasAfterSlot,\n\t\t\t[styles.before]: hasBeforeSlot,\n\t\t\t[styles.both]: hasBothSlot,\n\t\t\t[styles['border-disabled']]: disableBorder,\n\t\t},\n\t\tclassName\n\t);\n\n\treturn (\n\t\t<Paper className={paperClasses} {...rootProps}>\n\t\t\t{slotBefore}\n\t\t\t{content}\n\t\t\t{slotAfter}\n\t\t</Paper>\n\t);\n}"}