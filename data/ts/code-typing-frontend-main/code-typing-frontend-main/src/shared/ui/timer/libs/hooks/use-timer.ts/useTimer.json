{"start_line": 4, "code": "useTimer = (options: UseTimerOptions) => {\n    const { startSeconds, timeout = 20, direction, onEnd } = options\n\n    const [timeMs, setTimeMs] = useState(startSeconds * 1000)\n    const [isRunning, setIsRunning] = useState(false)\n    const [isEnded, setIsEnded] = useState(false)\n\n    const intervalRef = useRef<NodeJS.Timeout | null>(null)\n\n    const intervalByDirection: Record<TimerDirection, (startDate: Date) => NodeJS.Timeout> = {\n        down: startDate => {\n            return setInterval(() => {\n                const now = new Date()\n                const newDate = startSeconds * 1000 - (now.getTime() - startDate.getTime())\n\n                if (newDate > 0) return setTimeMs(newDate)\n\n                setTimeMs(0)\n                clearInterval(intervalRef.current!)\n                setIsRunning(false)\n                setIsEnded(true)\n                setTimeMs(newDate)\n            }, timeout)\n        },\n        up: startDate => {\n            return setInterval(() => {\n                const now = new Date()\n                setTimeMs(startSeconds * 1000 + (now.getTime() - startDate.getTime()))\n            }, timeout)\n        }\n    }\n\n    useEffect(() => {\n        if (isEnded) {\n            onEnd && onEnd()\n            setIsEnded(false)\n        }\n    }, [isEnded])\n\n    const start = () => {\n        setIsRunning(true)\n        const startTimeNow = new Date()\n\n        intervalRef.current = intervalByDirection[direction](startTimeNow)\n    }\n\n    const stop = () => {\n        clearInterval(intervalRef.current!)\n    }\n\n    const reset = () => {\n        clearInterval(intervalRef.current!)\n        setTimeMs(startSeconds * 1000)\n    }\n\n    return { time: timeMs, isRunning, start, stop, reset }\n}"}