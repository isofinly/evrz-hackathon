{"start_line": 17, "code": "TypingCodeHandlersProvider = ({ children }: { children: ReactNode }) => {\n    const [resultRef, containerRef, { scrollIntoView: scrollToResult, scrollTo }] =\n        useScrollIntoView<HTMLDivElement>(-50)\n    const inputRef = useRef<HTMLInputElement>(null)\n\n    const { randomText, newRandomText, rows } = useRandomCode()\n\n    const { typingValue, currentRowRightSymbols, prevRowsRightSymbols, currentRowIndex } =\n        useCurrentRow()\n    const { setTypingValue, nextRow, setValueWithTab, resetState } = useCurrentRowHandlers()\n\n    const { isError, errorsCount } = useCodeErrors()\n    const { setErrorsCount, setIsError, incrementErrors } = useCodeErrorsHandlers()\n\n    const { startResult, tickResult, endResult, clearResult } = useResult()\n\n    const { startTick, endTick } = useTick(() => {\n        const date = new Date()\n        tickResult({ symbols: prevRowsRightSymbols + currentRowRightSymbols, date })\n    })\n\n    const {\n        timer: { timerStatus },\n        startTimer,\n        stopTimer,\n        resetTimer\n    } = useTypingCodeTimer()\n\n    const typingAction = useTypingAction()\n    const { isNotStarted, startTyping, endTyping, resetTyping, isEnded } = typingAction\n\n    const handleStart = () => {\n        if (!randomText) return\n\n        startTyping()\n        const dateStart = new Date()\n        startTimer(dateStart.valueOf())\n        startTick()\n        startResult({ startTime: dateStart, text: randomText })\n    }\n\n    const handleEnd = () => {\n        const dateEnd = new Date()\n        endTyping()\n        stopTimer(dateEnd.valueOf())\n        nextRow(rows)\n        endTick()\n        endResult({\n            endTime: dateEnd,\n            textSymbolCount: prevRowsRightSymbols + currentRowRightSymbols,\n            errorsCount\n        })\n    }\n\n    useEffect(() => {\n        if (isEnded) {\n            scrollToResult()\n        }\n    }, [isEnded])\n\n    const handleResetAll = () => {\n        resetState()\n        resetTimer()\n        resetTyping()\n        clearResult()\n        endTick()\n        setErrorsCount(0)\n        setIsError(false)\n    }\n\n    const handleNewText = () => {\n        handleResetAll()\n        newRandomText()\n    }\n\n    useEffect(() => {\n        return () => handleResetAll()\n    }, [randomText])\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n        if (!rows) return\n        const row = rows[currentRowIndex]\n\n        keyboardShortcuts<KeyboardEvent>({\n            Enter: () => {\n                if (row !== typingValue) return incrementErrors()\n                return nextRow(rows)\n            },\n            Tab: e => {\n                e.preventDefault()\n                setValueWithTab()\n            }\n        })(e)\n    }\n    const handleChangePrintingInput: ChangeEventHandler<HTMLInputElement> = e => {\n        const currentTypingValue = e.target.value\n        setTypingValue({ value: currentTypingValue, rows })\n        if (!rows) return\n\n        if (!rows[currentRowIndex].startsWith(currentTypingValue)) {\n            if (!isError) {\n                incrementErrors()\n                setIsError(true)\n            }\n        } else setIsError(false)\n\n        const isFirstRow = currentRowIndex === 0\n        const isTimerNotStarted = timerStatus !== \"started\"\n\n        if (isFirstRow && isTimerNotStarted && isNotStarted) handleStart()\n\n        const isTypingValueRight = currentTypingValue === rows[currentRowIndex]\n        const isLastRow = currentRowIndex === rows.length - 1\n\n        if (isTypingValueRight && isLastRow) handleEnd()\n    }\n\n    return (\n        <TypingCodeHandlersContext.Provider\n            value={{\n                ...typingAction,\n                handleKeyDown,\n                handleChangePrintingInput,\n                containerRef,\n                resultRef,\n                handleNewText,\n                scrollTo,\n                resetTyping: handleResetAll,\n                endTyping: handleEnd,\n                startTyping: handleStart,\n                scrollToResult,\n                inputRef\n            }}\n        >\n            {children}\n        </TypingCodeHandlersContext.Provider>\n    )\n}"}